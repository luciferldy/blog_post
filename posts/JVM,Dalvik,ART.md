+++
date = "2015-04-23T09:18:02+08:00"
menu = "main"
tags = ["android"]
title = "JVM, Dalvik, ART"

+++

### JVM, Dalvik, ART

Java虚拟机（JVM）是一个虚构出来的虚拟机，是能在实际的计算机上仿真模拟各种计算机功能实现的，它有自己完善的硬件架构（如处理器，堆栈，寄存器等）还具有相应的指令系统。使用Java虚拟机程序是为了支持与操作系统无关，在任何系统中都能运行的程序。  

Dalvik虚拟机是Android程序的虚拟机，是Android中Java程序的运行基础。其指令集基于寄存器架构，执行其特有的文件格式——dex字节码来完成对对象的生命周期管理，堆栈管理，线程管理，安全异常管理，垃圾回收等重要功能。它的核心功能是实现库，大体由c语言实现。依赖于linux内核的一部分功能——线程机制，内存管理机制，能高效实用内存，并在低速CPU表现出高的性能。每一个Android应用在底层都会对一个对立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。  

ART架构与Dalvik的区别就是它的即时编译（JIT）,而且支持预先编译（AOT）。Dalvik每次执行时从字节码先转为原生代码才行，而ART可以只编译一次，然后每次运行时，都可以直接执行编译好的原生代码，不用重复编译，减少CPU的使用频率，降低了能耗。  

Dalvik基于寄存器，JVM基于stack, Dalvik执行的特有的dex文件格式，而JVM执行的是*.class文件格式。  

### 基于栈与基于寄存器架构哪一个更快  

实际的处理器，大多都是基于寄存器的架构，从侧面反映出基于寄存器比基于栈的架构更与实际的处理器相接近。基于寄存器架构的Dalvik比JVM执行效率更高。  
一个应用中会定义很多类，编译完成后会有很多响应的class文件，class文件间会有不少的冗余信息。dex字节码和标准的java的字节码（class）在结构上一个重要的区别就是dex字节码将多个文件整合在一起运行，减少了整体的文件尺寸，I/O操作，也提高了类的查找速度。

### 一个应用，一个虚拟机实例，一个进程

每个Android应用都运行在一个Dalvik虚拟机实例中，每一个Dalvik虚拟机实例都是一个独立的进程空间，每个进程之间可以通讯(IPC, Bindler)  
Zygote是虚拟机实例的孵化器：  
	AndroidRuntime.cpp中Zygote.main()的执行会完成一个分裂，分裂出来子进程继续初始化Java层的架构，这个分裂出来的进程就是system_server（PS: Zygote分裂出来的第一份虚拟机实例，当系统需要一个新的虚拟机实例时，Zygote通过复制自身，最快得出一个实例，所有虚拟机实例和Zygote共享一块内存）。  
当启动一个Java程序时，一个虚拟机实例就建立了。  
Dalvik VM就做了两件事：处理JNI， 提供Thread。