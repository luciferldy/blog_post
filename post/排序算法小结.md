+++
date = "2015-03-31T19:03:39+08:00"
menu = "main"
tags = ["algorithm"]
title = "排序算法小结"

+++

### 排序算法小结

在一般的面试中，很多面试官都会问到一些关于排序算法的问题以及使用场景，因此做一个简单的介绍。A[n]  

###### 稳定排序算法

1. 归并排序：将整个数组相邻两个分成一组，排序，相邻的组融合排序，最后再慢慢扩展到整个数组…… 时间复杂度O(n*log(n))
2. 冒泡排序：每次比较相邻元素，A[0]与A[1]进行比较，if A[0]>A[1]交换A[0], A[1], 然后比较A[1], A[2]比较
if A[2]>A[1] 交换A[2], A[1], 这样一次遍历之后A[n-1]为数组中最大元素，然后第二次比较到A[n-2]…… 时间复杂性为O(n^2)  
3. 插入排序：原则是当对第x个元素进行插入时，前x-1个元素已经排好序了，对第x个元素操作为 value = A[x], 从A[x-1]开始比较value和A[x-1]若是A[x-1]>value，将A[x-1]向后移动一位，再比较A[x-2]和value，若A[x-2]<value，就将value插在A[x-2]后面。 时间复杂性为O(n^2)  非常适合**元素个数有限，且事先有序**的情况  
4. 计数排序: O(n+k)    
5. 桶排序：O(n)  
6. 二叉排序树排序: O(nlogn)期望时间  
7. 基数排序：O(n·k)  

###### 不稳定排序
1. 快速排序：众所周知的，对从A[n]中选择一个中间元素作为锚节点x，分成A[x-1]和A[x+1]然后进行操作使A[x-1]<= x <=A[x+1] ，然后再从A[x-1], A[x+1]中去找锚节点，递归…… 时间复杂性O(n*log(n))  
2. 希尔排序：首先从头开始对距离为x的元素进行插入（？）排序，然后再对x-1的元素进行排序，等到最后基本有序后对所有元素插入排序。  
	先是这样的三组……  
	A[1], A[4], A[7], A[11]  
	A[2], A[5], A[8], A[12]  
	A[3], A[6], A[9], A[13]  
	然后再  
	A[1], A[3], A[5], A[7], A[9], A[11], A[13]  
	A[2], A[4], A[6], A[8], A[10], A[12]  
	时间复杂度O(n*log(n))
3. 堆排序：构造最大堆（或者最小堆）然后取走根节点，再对剩下元素构造最大堆或者最小堆…… 时间复杂性O(n*log(n))  
4. 选择排序：选择排序方式一般为从A[0]开始一直向后进行比较，比A[0]小（大的也可以，只不过最后排序方式可能不一样罢了）的直接与A[0]进行交换，第一次遍历完后，A[0]为数组中最小元素。然后同样方式对A[1]…… 时间复杂性为O(n^2)  